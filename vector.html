<html>
<script>

function Vector(x, y, z) {
    this.y = y || 0;
    this.x = x || 0;
    this.z = z || 0;
}

Vector.prototype.dot = function(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z;
};

Vector.prototype.cross = function(b) {
    var cross = new Vector();
    var a     = this;

    cross.x = a.y * b.z - a.z * b.y;
    cross.y = a.z * b.x - a.x * b.z;
    cross.z = a.x * b.y - a.y * b.x;

    return cross;
};

Vector.prototype.perp = function() {
    if(this.z != 0) {
        throw Error("perp only works on 2D vectors.");
    }

    return new Vector(-this.y, this.x, 0);
};

Vector.prototype.log = function(prefix) {
    prefix = prefix || "";
    console.log(prefix + " vector(" + this.x + ", " + this.y + ")");
    return this;
};

Vector.prototype.normalized = function() {
    var len = Math.sqrt(this.lengthSq());

    return new Vector(
        this.x / len,
        this.y / len,
        this.z / len
    );
};

Vector.prototype.lengthSq = function() {
    return Math.pow(this.x, 2) + Math.pow(this.y, 2) + Math.pow(this.z, 2);
}

Vector.prototype.projectOnto = function(b) {

    var dp  = this.dot(b);
    var len = b.lengthSq();

    console.log("dp", dp);
    console.log("len", len);

    console.log("math: ", dp, "/", len, "*",b.x);

    return new Vector(
        dp / len * b.x,
        dp / len * b.y,
        dp / len * b.z
    );
};

function Line(a, b) {
    this.a = a;
    this.b = b;
}

Line.prototype.direction = function() {
    return new Vector(
        this.b.x - this.a.x,
        this.b.y - this.a.y,
        this.b.z - this.a.z
    );
};

Line.prototype.normal = function() {

    // Shorthand for 2D:
    if(this.a.z != 0 || this.b.z != 0) {
        throw Error("3D normals not supported, yet.");
    }

    return this.direction().perp();
};

Line.prototype.projectOnto = function(axis) {
    var aProjected = this.a.projectOnto(axis);
    var bProjected = this.b.projectOnto(axis);

    aProjected.log("aProjected:");
    bProjected.log("bProjected");

    return new Line(
        aProjected,
        bProjected
    );
};

Line.prototype.log = function(prefix) {
    prefix = prefix || "";
    console.log(prefix + " line(" + this.a.x + ", " + this.a.y  + ", " + this.b.x  + ", " + this.b.y + ")");
    return this;
};

var a = new Line(
    new Vector(100, 0),
    new Vector(290, 120)
);

var b = new Line(
    new Vector(200, 0),
    new Vector(100, 120)
);

// Find the normals, we shall project all vertices on these:
var normalA = a.normal().normalized().log("line a normal normalized:");
var normalB = b.normal().normalized().log("line b normal normalized:");

if(
    eitherFit(a.projectOnto(normalB), b.projectOnto(normalB))
        &&
    eitherFit(a.projectOnto(normalA), b.projectOnto(normalA))
) {
    console.log("It fits!");
} else {
    console.log("It does not quite fit.");
}

function eitherFit(her, him) {
    return (
        ((
            Math.max(him.a.x, him.b.x) > Math.max(her.a.x, her.b.x)
            &&
            Math.min(him.a.x, him.b.x) < Math.min(her.a.x, her.b.x)
        ) || (
            Math.max(him.a.x, him.b.x) < Math.max(her.a.x, her.b.x)
            &&
            Math.min(him.a.x, him.b.x) > Math.min(her.a.x, her.b.x)
        ))
        &&
        ((
            Math.max(him.a.y, him.b.y) > Math.max(her.a.y, her.b.y)
            &&
            Math.min(him.a.y, him.b.y) < Math.min(her.a.y, her.b.y)
        ) || (
            Math.max(him.a.y, him.b.y) < Math.max(her.a.y, her.b.y)
            &&
            Math.min(him.a.y, him.b.y) > Math.min(her.a.y, her.b.y)
        ))
    );
}

//var bOna = b.projectOnto(normalA);
//bOna.log("bOna");

/*
var axis = pane.normalized().log("normalized pane:");
var meh  = new Vector(-43, 213, 0);

meh.projectOnto(axis).log("projected:");
*/

</script>

</html>
